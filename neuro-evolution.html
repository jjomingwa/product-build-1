<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>신경 진화 시뮬레이터 | Neuro-evolution Sim</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;400&display=swap');
        body { margin: 0; overflow: hidden; background: #00050a; color: #fff; font-family: 'Noto Sans KR', sans-serif; }
        canvas { display: block; }
        .ui-panel { position: absolute; top: 20px; left: 20px; background: rgba(0, 10, 20, 0.85); padding: 20px; border: 1px solid #00ffff; border-radius: 10px; backdrop-filter: blur(10px); width: 280px; z-index: 100; }
        h1 { font-family: 'Orbitron'; font-size: 1.1rem; color: #00ffff; margin: 0 0 10px 0; }
        .btn { display: inline-block; background: transparent; border: 1px solid #00ffff; color: #00ffff; padding: 5px 12px; font-size: 0.8rem; cursor: pointer; text-decoration: none; border-radius: 3px; margin: 5px 2px; transition: 0.3s; }
        .btn:hover { background: #00ffff; color: #000; }
        #guide-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 2px solid #00ffff; padding: 30px; border-radius: 15px; z-index: 2000; max-width: 500px; }
        .guide-content h2 { color: #00ffff; font-family: 'Orbitron'; }
        .guide-content p { color: #ccc; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="ui-panel">
        <h1 data-en="NEURO-EVOLUTION" data-ko="신경 진화 시뮬레이터">NEURO-EVOLUTION</h1>
        <div id="stats" style="font-size: 0.8rem; margin-bottom: 10px;">
            <div data-en="Generation: " data-ko="세대: "><span id="gen-val">1</span></div>
            <div data-en="Best Fitness: " data-ko="최고 적응도: "><span id="fit-val">0</span></div>
        </div>
        <button class="btn" onclick="toggleGuide()" data-en="GUIDE" data-ko="가이드 보기">GUIDE</button>
        <button class="btn" onclick="shareURL()" data-en="SHARE URL" data-ko="상태 공유">SHARE URL</button>
        <a href="index.html" class="btn" data-en="HUB" data-ko="허브로 돌아가기">HUB</a>
    </div>

    <div id="guide-modal">
        <div class="guide-content">
            <h2 data-en="HOW IT WORKS" data-ko="작동 원리">HOW IT WORKS</h2>
            <p data-en="Each agent has a brain made of LIF (Leaky Integrate-and-Fire) neurons. They sense food locations and use their neural network to decide where to turn. The ones that eat more food pass their neural weights to the next generation." 
               data-ko="각 에이전트는 LIF(Leaky Integrate-and-Fire) 뉴런으로 구성된 뇌를 가지고 있습니다. 이들은 먹이의 위치를 감지하고 신경망을 통해 회전 방향을 결정합니다. 먹이를 많이 먹은 에이전트는 자신의 신경망 가중치를 다음 세대에 전달합니다.">
            </p>
            <button class="btn" onclick="toggleGuide()" data-en="CLOSE" data-ko="닫기">CLOSE</button>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

    <script>
        // --- Core Neuro-evolution Engine ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // URL State Serialization
        function shareURL() {
            const state = {
                gen: generation,
                weights: agents[0].brain.weights
            };
            const encoded = btoa(JSON.stringify(state));
            const url = window.location.origin + window.location.pathname + '?state=' + encoded;
            navigator.clipboard.writeText(url);
            alert(isKorean ? "상태가 URL로 복사되었습니다!" : "State copied to URL!");
        }

        function loadState() {
            const params = new URLSearchParams(window.location.search);
            const stateStr = params.get('state');
            if (stateStr) {
                try {
                    const state = JSON.parse(atob(stateStr));
                    // Apply state to first generation...
                } catch(e) { console.error("Failed to load state", e); }
            }
        }

        class LIFNeuron {
            constructor() {
                this.v = -70; this.vRest = -70; this.vThresh = -50;
                this.tau = 10; this.refractory = 0;
            }
            update(input) {
                if (this.refractory > 0) { this.refractory--; this.v = -80; return 0; }
                this.v += (-(this.v - this.vRest) + input) / this.tau;
                if (this.v >= this.vThresh) { this.v = -80; this.refractory = 2; return 1; }
                return 0;
            }
        }

        class Brain {
            constructor(weights = null) {
                this.neurons = [new LIFNeuron(), new LIFNeuron()]; // 0: Left Motor, 1: Right Motor
                this.weights = weights || Array.from({length: 6}, () => Math.random() * 20 - 10);
            }
            think(sensors) {
                // sensors: [leftFoodDist, centerFoodDist, rightFoodDist]
                const leftInput = sensors[0] * this.weights[0] + sensors[1] * this.weights[1] + sensors[2] * this.weights[2];
                const rightInput = sensors[0] * this.weights[3] + sensors[1] * this.weights[4] + sensors[2] * this.weights[5];
                
                const leftFire = this.neurons[0].update(leftInput);
                const rightFire = this.neurons[1].update(rightInput);
                return rightFire - leftFire; // Steering delta
            }
        }

        class Agent {
            constructor(brain = null) {
                this.x = Math.random() * width; this.y = Math.random() * height;
                this.angle = Math.random() * Math.PI * 2;
                this.brain = brain || new Brain();
                this.fitness = 0;
                this.alive = true;
            }
            update(foods) {
                if (!this.alive) return;
                
                // Simple 3-sector sensing
                let sensors = [0, 0, 0];
                foods.forEach(f => {
                    const dx = f.x - this.x; const dy = f.y - this.y;
                    const d = Math.hypot(dx, dy);
                    if (d < 100) {
                        const a = Math.atan2(dy, dx) - this.angle;
                        const normA = ((a + Math.PI) % (Math.PI * 2)) - Math.PI;
                        if (normA < -0.5) sensors[0] += (100-d)/100;
                        else if (normA > 0.5) sensors[2] += (100-d)/100;
                        else sensors[1] += (100-d)/100;

                        if (d < 10) { f.eaten = true; this.fitness += 1; }
                    }
                });

                const turn = this.brain.think(sensors);
                this.angle += turn * 0.1;
                this.x += Math.cos(this.angle) * 2;
                this.y += Math.sin(this.angle) * 2;
                
                this.x = (this.x + width) % width;
                this.y = (this.y + height) % height;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.fillStyle = '#00ffff'; ctx.beginPath(); 
                ctx.moveTo(8,0); ctx.lineTo(-4,-4); ctx.lineTo(-4,4); ctx.fill();
                ctx.restore();
            }
        }

        let agents = [];
        let foods = [];
        let generation = 1;
        let timer = 0;

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            agents = Array.from({length: 50}, () => new Agent());
            spawnFood();
        }

        function spawnFood() {
            foods = Array.from({length: 40}, () => ({x: Math.random()*width, y: Math.random()*height, eaten: false}));
        }

        function evolve() {
            agents.sort((a, b) => b.fitness - a.fitness);
            const best = agents.slice(0, 10);
            document.getElementById('fit-val').innerText = agents[0].fitness;
            
            const nextGen = [];
            for(let i=0; i<50; i++) {
                const parent = best[Math.floor(Math.random()*best.length)];
                const newWeights = parent.brain.weights.map(w => w + (Math.random()-0.5)*2);
                nextGen.push(new Agent(new Brain(newWeights)));
            }
            agents = nextGen;
            generation++;
            document.getElementById('gen-val').innerText = generation;
            spawnFood();
            timer = 0;
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 5, 10, 0.3)'; ctx.fillRect(0,0,width,height);
            
            foods.forEach(f => {
                if(!f.eaten) {
                    ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(f.x, f.y, 3, 0, Math.PI*2); ctx.fill();
                }
            });

            agents.forEach(a => { a.update(foods); a.draw(); });
            
            timer++;
            if(timer > 1000) evolve();
            requestAnimationFrame(animate);
        }

        function toggleGuide() {
            const m = document.getElementById('guide-modal');
            m.style.display = m.style.display === 'block' ? 'none' : 'block';
        }

        // Language Support
        const isKorean = navigator.language.startsWith('ko');
        function applyLang() {
            document.querySelectorAll('[data-en]').forEach(el => {
                el.innerText = el.getAttribute(isKorean ? 'data-ko' : 'data-en');
            });
        }

        window.onload = () => { init(); applyLang(); animate(); loadState(); };
    </script>
</body>
</html>
