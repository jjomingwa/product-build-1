<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>네온 수학 그래프 | Raymarching Engine</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;400;700&display=swap');
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Noto Sans KR', sans-serif; }
        #canvas-3d { width: 100vw; height: 100vh; display: block; }
        #controls { 
            position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 25px; 
            border: 2px solid #00ffff; border-radius: 12px; backdrop-filter: blur(15px); 
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3); width: 320px; z-index: 10;
        }
        h1 { font-family: 'Orbitron'; font-size: 1.2rem; color: #00ffff; margin: 0 0 10px 0; text-shadow: 0 0 10px #00ffff; }
        .desc { font-size: 0.8rem; color: #ccc; margin: 0 0 15px 0; line-height: 1.4; }
        select, input[type="text"] { width: 100%; padding: 12px; margin-bottom: 15px; background: #111; border: 1px solid #00ffff; color: #00ffff; font-family: 'Orbitron', 'Noto Sans KR'; font-size: 0.9rem; border-radius: 5px; box-sizing: border-box; }
        input[type="text"] { border-color: #ff00ff; color: #fff; }
        .btn-draw { width: 100%; background: #00ffff; border: none; color: #000; font-weight: bold; cursor: pointer; padding: 12px; border-radius: 5px; font-family: 'Orbitron', 'Noto Sans KR'; transition: 0.3s; margin-bottom: 10px; }
        .btn-draw:hover { background: #ff00ff; color: #fff; box-shadow: 0 0 20px #ff00ff; }
        .back-link { display: inline-block; margin-top: 10px; color: #ff00ff; text-decoration: none; font-size: 0.9rem; font-weight: bold; border: 2px solid #ff00ff; padding: 10px; border-radius: 8px; transition: 0.3s; background: rgba(255, 0, 255, 0.1); text-align: center; width: calc(100% - 2px); box-sizing: border-box; }
        #status-msg { font-size: 0.75rem; margin-bottom: 10px; color: #00ffff; font-family: 'Orbitron'; }
    </style>
</head>
<body>
    <canvas id="canvas-3d"></canvas>
    <div id="controls">
        <h1 data-en="RAYMARCHING GRAPHER" data-ko="네온 레이마칭 그래퍼">네온 레이마칭 그래퍼</h1>
        <p class="desc" data-en="Infinite precision 3D rendering using GPU Raymarching." data-ko="GPU 기반 레이마칭 기술을 사용하여 완벽하게 매끄러운 3D 입체 도형을 렌더링합니다.">GPU 기반 레이마칭 기술을 사용하여 완벽하게 매끄러운 3D 입체 도형을 렌더링합니다.</p>
        <div id="status-msg">ENGINE: GPU ACCELERATED</div>
        <select id="preset-select">
            <option value="" data-en="-- Examples --" data-ko="-- 예시 선택 --">-- 예시 선택 --</option>
            <option value="x^2 + y^2 + z^2 - 100 - 30*sin(t)">[3D] Pulsing Sphere (구)</option>
            <option value="(sqrt(x^2 + y^2) - 15)^2 + z^2 - 25">[3D] Torus (도넛)</option>
            <option value="z - 2*sin(sqrt(x^2 + y^2) - 3*t)">[3D] Animated Ripple (파동)</option>
            <option value="length(max(abs(vec3(x,y,z))-8.0, 0.0)) - 1.0">[3D] Rounded Cube (라운드 큐브)</option>
            <option value="y - 5*sin(x-t)*cos(3*x)">[2D] Dancing Wave (2D 파동)</option>
        </select>
        <input type="text" id="eq-input" value="x^2 + y^2 + z^2 - 100">
        <button class="btn-draw" id="draw-btn" data-en="RENDER GRAPH" data-ko="그래프 렌더링">그래프 렌더링</button>
        <a href="index.html" class="back-link" data-en="BACK TO HUB" data-ko="허브로 돌아가기">허브로 돌아가기</a>
    </div>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() { gl_Position = vec4(position, 0.0, 1.0); }
    </script>

    <script id="fs-template" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_cameraPos;
        uniform vec3 u_cameraDir;

        float map(vec3 p) {
            float x = p.x; float y = p.y; float z = p.z; float t = u_time;
            // Dynamic expression will be injected here
            return <EXPRESSION>;
        }

        vec3 getNormal(vec3 p) {
            vec2 e = vec2(0.01, 0.0);
            return normalize(vec3(
                map(p+e.xyy) - map(p-e.xyy),
                map(p+e.yxy) - map(p-e.yxy),
                map(p+e.yyx) - map(p-e.yyx)
            ));
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x);
            vec3 ro = u_cameraPos;
            vec3 rd = normalize(u_cameraDir + uv.x * vec3(1,0,0) * 0.8 + uv.y * vec3(0,1,0) * 0.8);
            
            // Simple Raymarch
            float d = 0.0;
            for(int i=0; i<100; i++) {
                vec3 p = ro + rd * d;
                float h = map(p);
                if(h < 0.01 || d > 100.0) break;
                d += h * 0.5; // Safety factor
            }

            vec3 color = vec3(0.02); // Background
            if(d < 100.0) {
                vec3 p = ro + rd * d;
                vec3 n = getNormal(p);
                float diff = max(dot(n, normalize(vec3(1,2,3))), 0.0);
                float spec = pow(max(dot(reflect(normalize(vec3(1,2,3)), n), rd), 0.0), 32.0);
                vec3 baseCol = 0.5 + 0.5 * cos(u_time + p.xyz * 0.1 + vec3(0,2,4));
                color = baseCol * (diff + 0.2) + spec * 0.5;
                color += vec3(0, 1, 1) * (1.0 / (1.0 + d * 0.1)) * 0.3; // Depth glow
            }
            
            // Grid floor
            if(d > 99.0) {
                float grid = (sin(ro.x + rd.x * 100.0) * 0.5 + 0.5) * (sin(ro.z + rd.z * 100.0) * 0.5 + 0.5);
                color += vec3(0, 0.5, 0.5) * pow(grid, 10.0) * 0.2;
            }

            gl_FragColor = vec4(pow(color, vec3(0.4545)), 1.0); // Gamma correction
        }
    </script>

    <script>
        const canvas = document.getElementById('canvas-3d');
        const gl = canvas.getContext('webgl');
        const eqInput = document.getElementById('eq-input');
        const drawBtn = document.getElementById('draw-btn');
        const presetSelect = document.getElementById('preset-select');

        let program;
        let startTime = Date.now();
        let camPos = { x: 0, y: 10, z: 35 };

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function updateShader() {
            let eq = eqInput.value.toLowerCase().replace(/\s+/g, '');
            // Simple sanitization and translation to GLSL
            let glslEq = eq.replace(/=/g, '-(') + (eq.includes('=') ? ')' : '');
            glslEq = glslEq.replace(/\^/g, '**'); // Note: GLSL uses pow(a,b)
            // Advanced replace for math functions to GLSL
            const mathFuncs = ['sin', 'cos', 'tan', 'sqrt', 'abs', 'length', 'max', 'min', 'pow'];
            mathFuncs.forEach(f => {
                const reg = new RegExp(f + '\\(', 'g');
                glslEq = glslEq.replace(reg, f + '(');
            });
            // Replace pow(a,b) pattern (simple regex for common cases)
            glslEq = glslEq.replace(/([a-z0-9\.\(\)]+)\*\*([a-z0-9\.\(\)]+)/g, 'pow($1,$2)');

            const fsSource = document.getElementById('fs-template').text.replace('<EXPRESSION>', glslEq);
            const vsSource = document.getElementById('vs').text;

            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            if(!fs) { alert("Invalid Expression for GPU Solver"); return; }

            const newProgram = gl.createProgram();
            gl.attachShader(newProgram, vs);
            gl.attachShader(newProgram, fs);
            gl.linkProgram(newProgram);
            program = newProgram;
            gl.useProgram(program);

            const posLoc = gl.getAttribLocation(program, "position");
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        }

        function render() {
            if(!program) return;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            const resLoc = gl.getUniformLocation(program, "u_resolution");
            gl.uniform2f(resLoc, canvas.width, canvas.height);
            
            const timeLoc = gl.getUniformLocation(program, "u_time");
            gl.uniform1f(timeLoc, (Date.now() - startTime) / 1000);
            
            const camPosLoc = gl.getUniformLocation(program, "u_cameraPos");
            gl.uniform3f(camPosLoc, camPos.x, camPos.y, camPos.z);
            
            const camDirLoc = gl.getUniformLocation(program, "u_cameraDir");
            gl.uniform3f(camDirLoc, 0, -0.3, -1); // Fixed look-at for now

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        drawBtn.onclick = updateShader;
        presetSelect.onchange = () => { if(presetSelect.value) { eqInput.value = presetSelect.value; updateShader(); } };
        
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        updateShader();
        render();

        // Basic Mouse Interaction for Camera
        let isDown = false;
        canvas.onmousedown = () => isDown = true;
        window.onmouseup = () => isDown = false;
        window.onmousemove = (e) => {
            if(isDown) {
                camPos.x += e.movementX * 0.1;
                camPos.y -= e.movementY * 0.1;
            }
        };
    </script>
</body>
</html>
