<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>네온 수학 그래프 | Dynamic Math Grapher</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;400;700&display=swap');
        body { margin: 0; overflow: hidden; background: #050505; color: #fff; font-family: 'Noto Sans KR', sans-serif; }
        
        #three-container, #canvas-2d { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #canvas-2d { z-index: 1; pointer-events: none; } 
        
        #controls { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            background: rgba(0,0,0,0.9); 
            padding: 25px; 
            border: 2px solid #00ffff; 
            border-radius: 12px; 
            backdrop-filter: blur(15px); 
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3); 
            width: 320px;
            z-index: 10;
        }
        h1 { font-family: 'Orbitron'; font-size: 1.2rem; color: #00ffff; margin: 0 0 10px 0; text-shadow: 0 0 10px #00ffff; }
        .desc { font-size: 0.8rem; color: #ccc; margin: 0 0 20px 0; line-height: 1.4; }
        
        select {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #111;
            border: 1px solid #00ffff;
            color: #00ffff;
            font-family: 'Orbitron', 'Noto Sans KR';
            font-size: 0.9rem;
            border-radius: 5px;
            box-sizing: border-box;
            cursor: pointer;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #ff00ff;
            color: #fff;
            font-family: 'Orbitron', 'Noto Sans KR';
            font-size: 1rem;
            border-radius: 5px;
            box-sizing: border-box;
        }
        input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 15px #ff00ff;
        }

        .btn-draw { 
            width: 100%;
            background: #00ffff; 
            border: none; 
            color: #000; 
            font-weight: bold;
            cursor: pointer; 
            padding: 12px; 
            border-radius: 5px; 
            font-family: 'Orbitron', 'Noto Sans KR'; 
            transition: 0.3s;
            margin-bottom: 10px;
        }
        .btn-draw:hover { background: #ff00ff; color: #fff; box-shadow: 0 0 20px #ff00ff; }

        .back-link { display: inline-block; margin-top: 15px; color: #ff00ff; text-decoration: none; font-size: 0.9rem; font-weight: bold; border: 2px solid #ff00ff; padding: 10px; border-radius: 8px; transition: 0.3s; background: rgba(0, 255, 255, 0.1); text-align: center; width: calc(100% - 2px); box-sizing: border-box; }
        .back-link:hover { background: #ff00ff; color: #000; box-shadow: 0 0 15px #ff00ff; }

        #status-msg { font-size: 0.75rem; margin-bottom: 10px; color: #00ffff; font-family: 'Orbitron'; }
        #error-msg { color: #ff3333; font-size: 0.8rem; margin-top: -10px; margin-bottom: 10px; display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
</head>
<body>
    <div id="three-container"></div>
    <canvas id="canvas-2d"></canvas>

    <div id="controls">
        <h1 data-en="DYNAMIC MATH GRAPHER" data-ko="동적 수학 그래프">동적 수학 그래프</h1>
        <p class="desc" data-en="Use 't' for animation! Just type z = sin(x - t)." data-ko="시간 변수 't'를 사용하여 움직이는 그래프를 그려보세요.">시간 변수 't'를 사용하여 움직이는 그래프를 그려보세요.</p>
        
        <div id="status-msg">READY</div>

        <select id="preset-select">
            <option value="" data-en="-- Examples --" data-ko="-- 예시 선택 --">-- 예시 선택 --</option>
            <option value="z = 2 * sin(sqrt(x^2 + y^2) - t)">[3D] Animated Ripple (파동)</option>
            <option value="z = sin(x - t) * cos(y + t)">[3D] Interference (간섭파)</option>
            <option value="z = (x^2 - y^2) / 5 * cos(t)">[3D] Wobbling Saddle (요동치는 말안장)</option>
            <option value="y = 5 * sin(x - t) * cos(3 * x)">[2D] Dancing Wave (춤추는 파동)</option>
            <option value="x^2 + y^2 = 25 + 10 * sin(t)">[2D] Pulsing Circle (박동하는 원)</option>
            <option value="y = z + x">Plane: y = z + x (3D)</option>
            <option value="x^2 + y^2 + z^2 = 100">Sphere: x^2 + y^2 + z^2 = 100</option>
        </select>

        <input type="text" id="eq-input" value="z = 2 * sin(sqrt(x^2 + y^2) - t)" placeholder="e.g., z = sin(x - t)">
        <div id="error-msg" data-en="Invalid expression." data-ko="수식이 올바르지 않습니다.">수식이 올바르지 않습니다.</div>

        <button class="btn-draw" id="draw-btn" data-en="RENDER GRAPH" data-ko="그래프 렌더링">그래프 렌더링</button>
        <a href="index.html" class="back-link" data-en="BACK TO HUB" data-ko="허브로 돌아가기">허브로 돌아가기</a>
    </div>

    <script>
        // Multi-language
        function applyLanguage(lang) {
            document.querySelectorAll('[data-en]').forEach(el => {
                const text = el.getAttribute(`data-${lang}`);
                if (text) el.innerText = text;
            });
        }
        applyLanguage(navigator.language.startsWith('ko') ? 'ko' : 'en');

        const eqInput = document.getElementById('eq-input');
        const drawBtn = document.getElementById('draw-btn');
        const presetSelect = document.getElementById('preset-select');
        const errorMsg = document.getElementById('error-msg');
        const statusMsg = document.getElementById('status-msg');
        const canvas2d = document.getElementById('canvas-2d');
        const ctx = canvas2d.getContext('2d');
        const threeContainer = document.getElementById('three-container');

        let scale2D = 50; 
        let time = 0;
        let isAnimated = false;
        let currentCompiled = null;
        let currentMode = null;

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        threeContainer.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const axesHelper = new THREE.AxesHelper(20); scene.add(axesHelper);
        const gridHelper = new THREE.GridHelper(40, 40, 0x444444, 0x222222); scene.add(gridHelper);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const p1 = new THREE.PointLight(0xff00ff, 1.5); p1.position.set(15, 20, 15); scene.add(p1);
        const p2 = new THREE.PointLight(0x00ffff, 1.5); p2.position.set(-15, -20, -15); scene.add(p2);

        let currentMesh = null;

        function solveZ(compiled, x, y, t, range = 15) {
            let low = -range, high = range;
            let bestZ = 0, minErr = Infinity;
            try {
                let directZ = compiled.evaluate({x, y, t});
                if (typeof directZ === 'number' && isFinite(directZ)) return directZ;
            } catch(e) {}
            for (let i = 0; i < 12; i++) {
                let mid = (low + high) / 2;
                let val = compiled.evaluate({x, y, z: mid, t});
                if (isNaN(val)) break;
                if (Math.abs(val) < minErr) { minErr = Math.abs(val); bestZ = mid; }
                let eps = 0.001;
                let valUp = compiled.evaluate({x, y, z: mid + eps, t});
                if ((valUp - val) * val > 0) high = mid; else low = mid;
            }
            return bestZ;
        }

        function detectMode(eq) {
            eq = eq.toLowerCase().replace(/\s+/g, '');
            isAnimated = eq.includes('t');
            const hasZ = eq.includes('z');
            const hasY = eq.includes('y');
            const hasEqual = eq.includes('=');
            let expr = eq;
            if (hasEqual) {
                let parts = eq.split('=');
                expr = `(${parts[0]}) - (${parts[1]})`;
                if (parts[0] === 'z') return { mode: '3D_EXPL', expr: parts[1] };
            }
            if (hasZ) return { mode: '3D_SOLVE', expr: expr };
            if (hasEqual || hasY) {
                if (eq.startsWith('y=')) return { mode: '2D_EXP', expr: eq.split('=')[1] };
                return { mode: '2D_IMP', expr: expr };
            }
            return { mode: '2D_EXP', expr: eq };
        }

        function drawGrid2D() {
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1; ctx.beginPath();
            let w = canvas2d.width, h = canvas2d.height;
            for(let x = w/2 % scale2D; x < w; x += scale2D) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
            for(let y = h/2 % scale2D; y < h; y += scale2D) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            ctx.stroke();
            ctx.strokeStyle = 'rgba(0,255,255,0.3)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
            ctx.strokeStyle = 'rgba(255,0,255,0.3)';
            ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();
        }

        function renderFrame() {
            if (!currentCompiled) return;
            const t = time;
            if (currentMode.startsWith('3D')) {
                const pos = currentMesh.geometry.attributes.position;
                const isExpl = currentMode === '3D_EXPL';
                const range = 15, segs = isAnimated ? 60 : 80; // Optimize for animation
                for (let i = 0; i < pos.count; i++) {
                    let x = pos.getX(i), y = pos.getY(i);
                    let z = isExpl ? currentCompiled.evaluate({x, y, t}) : solveZ(currentCompiled, x, y, t);
                    pos.setZ(i, Math.max(Math.min(z || 0, 15), -15));
                }
                currentMesh.geometry.attributes.position.needsUpdate = true;
                currentMesh.geometry.computeVertexNormals();
            } else {
                ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
                drawGrid2D();
                if (currentMode === '2D_EXP') {
                    ctx.beginPath(); ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3;
                    let first = true;
                    for (let px = 0; px < canvas2d.width; px+=2) {
                        let x = (px - canvas2d.width/2) / scale2D;
                        try {
                            let y = currentCompiled.evaluate({x, t});
                            let py = canvas2d.height/2 - y * scale2D;
                            if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
                        } catch (e) { first = true; }
                    }
                    ctx.stroke();
                } else if (currentMode === '2D_IMP') {
                    const res = isAnimated ? 6 : 4;
                    const w = canvas2d.width, h = canvas2d.height;
                    const cols = Math.ceil(w / res), rows = Math.ceil(h / res);
                    ctx.beginPath(); ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
                    for (let i = 0; i < cols; i++) {
                        let x = (i * res - w/2) / scale2D;
                        for (let j = 0; j < rows; j++) {
                            let y = -(j * res - h/2) / scale2D;
                            let v0 = currentCompiled.evaluate({x, y, t});
                            let v1 = currentCompiled.evaluate({x: x + res/scale2D, y, t});
                            let v2 = currentCompiled.evaluate({x: x + res/scale2D, y: y - res/scale2D, t});
                            let v3 = currentCompiled.evaluate({x, y: y - res/scale2D, t});
                            let px = i * res, py = j * res;
                            const getT = (a, b) => (a === b) ? 0.5 : a / (a - b);
                            if (v0 * v1 <= 0) { let tx = px + res * getT(v0, v1); ctx.moveTo(tx, py); ctx.lineTo(tx, py+1); }
                            if (v1 * v2 <= 0) { let ty = py + res * getT(v1, v2); ctx.moveTo(px+res, ty); ctx.lineTo(px+res-1, ty); }
                        }
                    }
                    ctx.stroke();
                }
            }
        }

        function drawCurrent() {
            let eq = eqInput.value; errorMsg.style.display = 'none';
            try {
                let p = detectMode(eq);
                currentMode = p.mode;
                currentCompiled = math.compile(p.expr);
                statusMsg.innerText = `MODE: ${p.mode} ${isAnimated ? '(ANIMATED)' : ''}`;
                
                if (p.mode.startsWith('3D')) {
                    threeContainer.style.zIndex = 1; axesHelper.visible = true; gridHelper.visible = true;
                    if (currentMesh) scene.remove(currentMesh);
                    const range = 15, segments = isAnimated ? 60 : 80;
                    const geo = new THREE.PlaneGeometry(range*2, range*2, segments, segments);
                    const mat = new THREE.MeshPhongMaterial({ color: 0x00ffff, specular: 0xff00ff, shininess: 80, side: THREE.DoubleSide, wireframe: true, transparent: true, opacity: 0.8 });
                    currentMesh = new THREE.Mesh(geo, mat); currentMesh.rotation.x = -Math.PI / 2;
                    scene.add(currentMesh);
                } else {
                    threeContainer.style.zIndex = -1; axesHelper.visible = false; gridHelper.visible = false;
                    if (currentMesh) { scene.remove(currentMesh); currentMesh = null; }
                }
                renderFrame();
            } catch(e) { errorMsg.style.display = 'block'; }
        }

        drawBtn.onclick = drawCurrent;
        presetSelect.onchange = () => { if (presetSelect.value) { eqInput.value = presetSelect.value; drawCurrent(); } };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            canvas2d.width = window.innerWidth; canvas2d.height = window.innerHeight;
            drawCurrent();
        });

        function animate() {
            requestAnimationFrame(animate);
            if (isAnimated) { time += 0.05; renderFrame(); }
            controls.update();
            renderer.render(scene, camera);
        }
        canvas2d.width = window.innerWidth; canvas2d.height = window.innerHeight;
        drawCurrent(); animate();
    </script>
</body>
</html>
