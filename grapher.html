<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>네온 레이마칭 그래퍼 | Fixed Precision</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;400;700&display=swap');
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Noto Sans KR', sans-serif; }
        #canvas-3d { width: 100vw; height: 100vh; display: block; }
        #controls { 
            position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.85); padding: 25px; 
            border: 2px solid #00ffff; border-radius: 12px; backdrop-filter: blur(15px); 
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3); width: 320px; z-index: 10;
        }
        h1 { font-family: 'Orbitron'; font-size: 1.2rem; color: #00ffff; margin: 0 0 10px 0; text-shadow: 0 0 10px #00ffff; }
        .desc { font-size: 0.8rem; color: #ccc; margin: 0 0 15px 0; line-height: 1.4; }
        select, input[type="text"] { width: 100%; padding: 12px; margin-bottom: 15px; background: #111; border: 1px solid #00ffff; color: #00ffff; font-family: 'Orbitron', 'Noto Sans KR'; font-size: 0.9rem; border-radius: 5px; box-sizing: border-box; }
        input[type="text"] { border-color: #ff00ff; color: #fff; }
        .btn-draw { width: 100%; background: #00ffff; border: none; color: #000; font-weight: bold; cursor: pointer; padding: 12px; border-radius: 5px; font-family: 'Orbitron', 'Noto Sans KR'; transition: 0.3s; margin-bottom: 10px; }
        .btn-draw:hover { background: #ff00ff; color: #fff; box-shadow: 0 0 20px #ff00ff; }
        .back-link { display: inline-block; margin-top: 10px; color: #ff00ff; text-decoration: none; font-size: 0.9rem; font-weight: bold; border: 2px solid #ff00ff; padding: 10px; border-radius: 8px; transition: 0.3s; background: rgba(255, 0, 255, 0.1); text-align: center; width: calc(100% - 2px); box-sizing: border-box; }
        #status-msg { font-size: 0.75rem; margin-bottom: 10px; color: #00ffff; font-family: 'Orbitron'; }
    </style>
</head>
<body>
    <canvas id="canvas-3d"></canvas>
    <div id="controls">
        <h1 data-en="RAYMARCHING GRAPHER" data-ko="네온 레이마칭 그래퍼">네온 레이마칭 그래퍼</h1>
        <p class="desc" data-en="Fixed precision engine. Smooth 3D surfaces guaranteed." data-ko="수치 안정성 강화 엔진. 구체와 복잡한 수식의 표면을 매끄럽게 렌더링합니다.">수치 안정성 강화 엔진. 구체와 복잡한 수식의 표면을 매끄럽게 렌더링합니다.</p>
        <div id="status-msg">PRECISION: HIGH</div>
        <select id="preset-select">
            <option value="" data-en="-- Examples --" data-ko="-- 예시 선택 --">-- 예시 선택 --</option>
            <option value="sqrt(x*x + y*y + z*z) - 10.0 - 2.0*sin(t)">[3D] Pulsing Sphere (구체)</option>
            <option value="(sqrt(x*x + y*y) - 15.0)^2 + z*z - 25.0">[3D] Torus (도넛)</option>
            <option value="z - 2.0*sin(sqrt(x*x + y*y) - 3.0*t)">[3D] Wave (파동)</option>
            <option value="max(abs(x),max(abs(y),abs(z))) - 8.0">[3D] Box (박스)</option>
        </select>
        <input type="text" id="eq-input" value="sqrt(x*x + y*y + z*z) - 10.0">
        <button class="btn-draw" id="draw-btn" data-en="RENDER GRAPH" data-ko="그래프 렌더링">그래프 렌더링</button>
        <a href="index.html" class="back-link" data-en="BACK TO HUB" data-ko="허브로 돌아가기">허브로 돌아가기</a>
    </div>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() { gl_Position = vec4(position, 0.0, 1.0); }
    </script>

    <script id="fs-template" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_cameraPos;

        float map(vec3 p) {
            float x = p.x; float y = p.y; float z = p.z; float t = u_time;
            float h = <EXPRESSION>;
            // Robust normalization for raymarching stability
            return h * 0.4; 
        }

        vec3 getNormal(vec3 p) {
            vec2 e = vec2(0.01, 0.0);
            return normalize(vec3(
                map(p+e.xyy) - map(p-e.xyy),
                map(p+e.yxy) - map(p-e.yxy),
                map(p+e.yyx) - map(p-e.yyx)
            ));
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x);
            vec3 ro = u_cameraPos;
            vec3 rd = normalize(vec3(uv, -1.2)); // Dynamic look-at logic
            
            float d = 0.0;
            float totalD = 0.0;
            for(int i=0; i<120; i++) {
                vec3 p = ro + rd * totalD;
                float h = map(p);
                if(abs(h) < 0.005 || totalD > 100.0) break;
                totalD += h;
            }

            vec3 color = vec3(0.01, 0.01, 0.02);
            if(totalD < 100.0) {
                vec3 p = ro + rd * totalD;
                vec3 n = getNormal(p);
                float diff = max(dot(n, normalize(vec3(1,2,3))), 0.0);
                vec3 baseCol = 0.5 + 0.5 * cos(u_time + p.xyz * 0.05 + vec3(0,2,4));
                color = baseCol * (diff + 0.3) + vec3(0.1, 0.8, 1.0) * pow(1.0 - max(dot(n, -rd), 0.0), 3.0);
                color += vec3(0.8, 0.1, 1.0) * 0.2; // Neon ambient
            }
            
            // Grid floor
            float floorDist = (ro.y + 15.0) / -rd.y;
            if(floorDist > 0.0 && (totalD > floorDist || totalD > 99.0)) {
                vec3 fp = ro + rd * floorDist;
                float g = smoothstep(0.0, 0.1, abs(sin(fp.x)) * abs(sin(fp.z)));
                color += vec3(0, 0.3, 0.4) * (1.0 - g) * (20.0 / (20.0 + floorDist));
            }

            gl_FragColor = vec4(pow(color, vec3(0.8)), 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('canvas-3d');
        const gl = canvas.getContext('webgl');
        const eqInput = document.getElementById('eq-input');
        const drawBtn = document.getElementById('draw-btn');
        const presetSelect = document.getElementById('preset-select');

        let program;
        let startTime = Date.now();
        let camPos = { x: 0, y: 5, z: 40 };

        function updateShader() {
            let eq = eqInput.value.toLowerCase().replace(/\s+/g, '');
            let glslEq = eq.includes('=') ? `(${eq.split('=')[0]}) - (${eq.split('=')[1]})` : eq;
            
            // Clean-up expression for GLSL
            glslEq = glslEq.replace(/x\^2/g, "(x*x)").replace(/y\^2/g, "(y*y)").replace(/z\^2/g, "(z*z)");

            const fsSource = document.getElementById('fs-template').text.replace('<EXPRESSION>', glslEq);
            const vsSource = document.getElementById('vs').text;

            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSource); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSource); gl.compileShader(fs);

            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(fs));
                alert("수식 분석 오류: 올바른 수식을 입력해 주세요.");
                return;
            }

            program = gl.createProgram();
            gl.attachShader(program, vs); gl.attachShader(program, fs);
            gl.linkProgram(program); gl.useProgram(program);

            const posLoc = gl.getAttribLocation(program, "position");
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        }

        function render() {
            if(!program) return;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(gl.getUniformLocation(program, "u_resolution"), canvas.width, canvas.height);
            gl.uniform1f(gl.getUniformLocation(program, "u_time"), (Date.now() - startTime) / 1000);
            gl.uniform3f(gl.getUniformLocation(program, "u_cameraPos"), camPos.x, camPos.y, camPos.z);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        drawBtn.onclick = updateShader;
        presetSelect.onchange = () => { if(presetSelect.value) { eqInput.value = presetSelect.value; updateShader(); } };
        
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        updateShader(); render();

        let isDown = false;
        canvas.onmousedown = () => isDown = true;
        window.onmouseup = () => isDown = false;
        window.onmousemove = (e) => {
            if(isDown) {
                camPos.x += e.movementX * 0.1;
                camPos.y -= e.movementY * 0.1;
            }
        };
    </script>
</body>
</html>
