<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>네온 수학 그래프 | Math Grapher 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;400;700&display=swap');
        body { margin: 0; overflow: hidden; background: #050505; color: #fff; font-family: 'Noto Sans KR', sans-serif; }
        
        #three-container, #canvas-2d { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #canvas-2d { z-index: 1; pointer-events: none; } 
        
        #controls { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            background: rgba(0,0,0,0.85); 
            padding: 25px; 
            border: 2px solid #00ffff; 
            border-radius: 12px; 
            backdrop-filter: blur(10px); 
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); 
            width: 320px;
            z-index: 10;
        }
        h1 { font-family: 'Orbitron'; font-size: 1.2rem; color: #00ffff; margin: 0 0 10px 0; text-shadow: 0 0 10px #00ffff; }
        .desc { font-size: 0.8rem; color: #ccc; margin: 0 0 20px 0; line-height: 1.4; }
        
        input[type="text"], select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #fff;
            font-family: 'Orbitron', 'Noto Sans KR';
            font-size: 1rem;
            border-radius: 5px;
            box-sizing: border-box;
        }
        input[type="text"]:focus, select:focus {
            outline: none;
            box-shadow: 0 0 10px #00ffff;
        }

        .btn-draw { 
            width: 100%;
            background: #00ffff; 
            border: none; 
            color: #000; 
            font-weight: bold;
            cursor: pointer; 
            padding: 12px; 
            border-radius: 5px; 
            font-family: 'Orbitron', 'Noto Sans KR'; 
            transition: 0.3s;
            margin-bottom: 10px;
        }
        .btn-draw:hover { background: #ff00ff; color: #fff; box-shadow: 0 0 15px #ff00ff; }

        .back-link { display: inline-block; margin-top: 15px; color: #ff00ff; text-decoration: none; font-size: 0.9rem; font-weight: bold; border: 2px solid #ff00ff; padding: 10px; border-radius: 8px; transition: 0.3s; background: rgba(255, 0, 255, 0.1); text-align: center; width: calc(100% - 24px); box-sizing: border-box; }
        .back-link:hover { background: #ff00ff; color: #000; box-shadow: 0 0 15px #ff00ff; }

        #error-msg { color: #ff3333; font-size: 0.8rem; margin-top: -10px; margin-bottom: 10px; display: none; }
    </style>
    <!-- Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Math.js for parsing and evaluating expressions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
</head>
<body>
    <div id="three-container"></div>
    <canvas id="canvas-2d"></canvas>

    <div id="controls">
        <h1 data-en="NEON MATH GRAPHER" data-ko="네온 수학 그래프">네온 수학 그래프</h1>
        <p class="desc" data-en="Auto-detects 2D/3D and implicit functions for beautiful rendering." data-ko="수식을 입력하면 2D(양/음함수) 및 3D를 자동으로 분석하여 시각화합니다.">수식을 입력하면 2D(양/음함수) 및 3D를 자동으로 분석하여 시각화합니다.</p>
        
        <select id="preset-select">
            <option value="" data-en="-- Select Preset --" data-ko="-- 멋있는 예시 선택 --">-- 멋있는 예시 선택 --</option>
            <option value="z = sin(sqrt(x^2 + y^2))">3D Ripple (파동)</option>
            <option value="z = (x^2 - y^2) / 10">3D Saddle (말안장)</option>
            <option value="z = sin(x) * cos(y)">3D Interference (간섭)</option>
            <option value="y = sin(x) * cos(20 * x)">2D Butterfly Pulse (나비 곡선)</option>
            <option value="(x^2 + y^2 - 1)^3 - x^2 * y^3 = 0">2D Heart (하트 음함수)</option>
            <option value="x^2 + y^2 = 25">2D Circle (원 음함수)</option>
        </select>

        <input type="text" id="eq-input" value="z = sin(sqrt(x^2 + y^2))">
        <div id="error-msg" data-en="Invalid expression." data-ko="수식이 올바르지 않습니다.">수식이 올바르지 않습니다.</div>

        <button class="btn-draw" id="draw-btn" data-en="RENDER GRAPH" data-ko="그래프 렌더링">그래프 렌더링</button>
        <a href="index.html" class="back-link" data-en="BACK TO HUB" data-ko="허브로 돌아가기">허브로 돌아가기</a>
    </div>

    <script>
        // Multi-language
        function applyLanguage(lang) {
            document.querySelectorAll('[data-en]').forEach(el => {
                const text = el.getAttribute(`data-${lang}`);
                if (text) el.innerText = text;
            });
        }
        applyLanguage(navigator.language.startsWith('ko') ? 'ko' : 'en');

        // Elements
        const eqInput = document.getElementById('eq-input');
        const drawBtn = document.getElementById('draw-btn');
        const presetSelect = document.getElementById('preset-select');
        const errorMsg = document.getElementById('error-msg');
        const canvas2d = document.getElementById('canvas-2d');
        const ctx = canvas2d.getContext('2d');
        const threeContainer = document.getElementById('three-container');

        // State
        let scale2D = 50; 

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.03);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(12, 12, 12);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        threeContainer.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xff00ff, 1);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);
        const pointLight2 = new THREE.PointLight(0x00ffff, 1);
        pointLight2.position.set(-10, -20, -10);
        scene.add(pointLight2);

        let currentMesh = null;

        function resize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            canvas2d.width = window.innerWidth;
            canvas2d.height = window.innerHeight;
            drawCurrent(); 
        }
        window.addEventListener('resize', resize);
        resize();

        // Parser & Mode Detection
        function detectMode(eq) {
            eq = eq.toLowerCase().replace(/\s+/g, '');
            if (eq.includes('z') && eq.includes('=')) {
                let parts = eq.split('=');
                if (parts[0] === 'z') return { mode: '3D', expr: parts[1] };
            }
            if (eq.includes('y') && eq.includes('=')) {
                let parts = eq.split('=');
                if (parts[0] === 'y') return { mode: '2D_EXP', expr: parts[1] };
            }
            if (eq.includes('=')) {
                let parts = eq.split('=');
                return { mode: '2D_IMP', expr: `(${parts[0]}) - (${parts[1]})` };
            }
            
            try {
                const node = math.parse(eq);
                const symbols = node.filter(n => n.isSymbolNode).map(n => n.name);
                if (symbols.includes('y') && symbols.includes('x')) {
                    return { mode: '3D', expr: eq }; 
                } else {
                    return { mode: '2D_EXP', expr: eq }; 
                }
            } catch(e) {
                return { mode: '2D_EXP', expr: eq };
            }
        }

        function drawGrid2D() {
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            let w = canvas2d.width, h = canvas2d.height;
            for(let x = w/2 % scale2D; x < w; x += scale2D) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
            for(let y = h/2 % scale2D; y < h; y += scale2D) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h);
            ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
            ctx.stroke();
        }

        function getT(v1, v2) {
            if (v1 === v2) return 0.5;
            return v1 / (v1 - v2);
        }

        // Marching Squares Algorithm for Implicit Functions
        function draw2DImplicit(expr) {
            const compiled = math.compile(expr);
            ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
            drawGrid2D();
            
            const resolution = 4;
            const width = canvas2d.width;
            const height = canvas2d.height;
            const cols = Math.ceil(width / resolution);
            const rows = Math.ceil(height / resolution);
            
            let values = new Float32Array((cols + 1) * (rows + 1));
            
            for (let i = 0; i <= cols; i++) {
                let x = (i * resolution - width/2) / scale2D;
                for (let j = 0; j <= rows; j++) {
                    let y = -(j * resolution - height/2) / scale2D; 
                    try {
                        values[i + j * (cols + 1)] = compiled.evaluate({x: x, y: y});
                    } catch(e) {
                        values[i + j * (cols + 1)] = 1;
                    }
                }
            }
            
            ctx.beginPath();
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff00ff';
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let v0 = values[i + j * (cols + 1)];
                    let v1 = values[i + 1 + j * (cols + 1)];
                    let v2 = values[i + 1 + (j + 1) * (cols + 1)];
                    let v3 = values[i + (j + 1) * (cols + 1)];
                    
                    let px = i * resolution;
                    let py = j * resolution;
                    
                    let pts = [];
                    if (v0 * v1 <= 0) pts.push({x: px + resolution * getT(v0, v1), y: py});
                    if (v1 * v2 <= 0) pts.push({x: px + resolution, y: py + resolution * getT(v1, v2)});
                    if (v2 * v3 <= 0) pts.push({x: px + resolution * (1 - getT(v2, v3)), y: py + resolution});
                    if (v3 * v0 <= 0) pts.push({x: px, y: py + resolution * (1 - getT(v3, v0))});
                    
                    if (pts.length >= 2) {
                        ctx.moveTo(pts[0].x, pts[0].y);
                        ctx.lineTo(pts[1].x, pts[1].y);
                        if(pts.length === 4) {
                            ctx.moveTo(pts[2].x, pts[2].y);
                            ctx.lineTo(pts[3].x, pts[3].y);
                        }
                    }
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // Standard Explicit Function Plotting
        function draw2DExplicit(expr) {
            const compiled = math.compile(expr);
            const width = canvas2d.width;
            const height = canvas2d.height;
            ctx.clearRect(0, 0, width, height);
            drawGrid2D();
            
            ctx.beginPath();
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffff';
            
            let first = true;
            for (let px = 0; px < width; px+=2) {
                let x = (px - width/2) / scale2D;
                try {
                    let y = compiled.evaluate({x: x});
                    if (isNaN(y) || !isFinite(y)) { first = true; continue; }
                    let py = height/2 - y * scale2D;
                    if (first) { ctx.moveTo(px, py); first = false; }
                    else { ctx.lineTo(px, py); }
                } catch (e) {
                    first = true;
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // 3D Parametric Plane
        function draw3DExplicit(expr) {
            const compiled = math.compile(expr);
            if (currentMesh) scene.remove(currentMesh);
            
            const range = 15;
            const segments = 120;
            const geometry = new THREE.PlaneGeometry(range*2, range*2, segments, segments);
            const pos = geometry.attributes.position;
            
            for (let i = 0; i < pos.count; i++) {
                let x = pos.getX(i);
                let y = pos.getY(i);
                let z = 0;
                try {
                    z = compiled.evaluate({x: x, y: y});
                    if (isNaN(z) || !isFinite(z)) z = 0;
                    z = Math.max(Math.min(z, 20), -20);
                } catch(e) {}
                pos.setZ(i, z);
            }
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x001122,
                specular: 0xff00ff,
                shininess: 100,
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.85
            });
            
            currentMesh = new THREE.Mesh(geometry, material);
            currentMesh.rotation.x = -Math.PI / 2;
            scene.add(currentMesh);
        }

        function drawCurrent() {
            let eq = eqInput.value;
            errorMsg.style.display = 'none';
            try {
                let parsed = detectMode(eq);
                
                if (parsed.mode === '3D') {
                    canvas2d.style.pointerEvents = 'none';
                    threeContainer.style.zIndex = 1;
                    ctx.clearRect(0,0,canvas2d.width, canvas2d.height);
                    draw3DExplicit(parsed.expr);
                } else if (parsed.mode === '2D_EXP') {
                    canvas2d.style.pointerEvents = 'auto';
                    threeContainer.style.zIndex = -1;
                    if (currentMesh) { scene.remove(currentMesh); currentMesh = null; }
                    draw2DExplicit(parsed.expr);
                } else if (parsed.mode === '2D_IMP') {
                    canvas2d.style.pointerEvents = 'auto';
                    threeContainer.style.zIndex = -1;
                    if (currentMesh) { scene.remove(currentMesh); currentMesh = null; }
                    draw2DImplicit(parsed.expr);
                }
            } catch(e) {
                errorMsg.style.display = 'block';
                console.error(e);
            }
        }

        drawBtn.onclick = drawCurrent;
        presetSelect.onchange = () => {
            if (presetSelect.value) {
                eqInput.value = presetSelect.value;
                drawCurrent();
            }
        };

        eqInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') drawCurrent();
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Handles autoRotate
            renderer.render(scene, camera);
        }
        
        drawCurrent();
        animate();

    </script>
</body>
</html>
