<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIF 뉴런 네트워크 | Spiking Neuron Sim</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;400&display=swap');
        body { margin: 0; overflow: hidden; background: #000814; color: #fff; font-family: 'Noto Sans KR', sans-serif; }
        canvas { display: block; }
        #overlay { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #00ff88; border-radius: 10px; }
        h1 { font-family: 'Orbitron'; font-size: 1.2rem; color: #00ff88; margin: 0; }
        .back-link { display: inline-block; margin-top: 15px; color: #00ffff; text-decoration: none; font-size: 0.8rem; border: 1px solid #00ffff; padding: 5px 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>LIF NEURON NETWORK</h1>
        <p style="font-size: 0.8rem; color: #ccc;">Leaky Integrate-and-Fire 모델 시각화</p>
        <div style="font-size: 0.7rem;">뉴런을 클릭하여 자극을 주세요.</div>
        <a href="index.html" class="back-link">HUB로 돌아가기</a>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let neurons = [];
        let connections = [];

        class Neuron {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.v = -70; // 막전위 (mV)
                this.vRest = -70;
                this.vThresh = -50;
                this.vReset = -80;
                this.tau = 20; // Time constant
                this.refractory = 0;
                this.lastSpike = -100;
            }
            update(dt, inputI) {
                if (this.refractory > 0) {
                    this.refractory -= dt;
                    this.v = this.vReset;
                    return false;
                }
                // dv/dt = (-(v - vRest) + I) / tau
                let dv = (-(this.v - this.vRest) + inputI) / this.tau;
                this.v += dv * dt;

                if (this.v >= this.vThresh) {
                    this.v = 40; // Action Potential Peak
                    this.refractory = 5;
                    this.lastSpike = performance.now();
                    return true; // Spike!
                }
                return false;
            }
            draw() {
                let intensity = (this.v + 80) / 120;
                ctx.shadowBlur = intensity * 20;
                ctx.shadowColor = '#00ff88';
                ctx.fillStyle = `rgb(0, ${Math.floor(intensity * 255)}, ${Math.floor(intensity * 150)})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI*2); ctx.fill();
                
                if (performance.now() - this.lastSpike < 100) {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke();
                }
            }
        }

        class Pulse {
            constructor(from, to) {
                this.from = from; this.to = to; this.progress = 0;
            }
            update() { this.progress += 0.05; return this.progress >= 1; }
            draw() {
                let x = this.from.x + (this.to.x - this.from.x) * this.progress;
                let y = this.from.y + (this.to.y - this.from.y) * this.progress;
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
            }
        }

        let pulses = [];

        const Simulation = {
            init() {
                width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight;
                neurons = []; connections = []; pulses = [];
                for(let i=0; i<15; i++) {
                    neurons.push(new Neuron(Math.random()*width*0.8 + width*0.1, Math.random()*height*0.8 + height*0.1));
                }
                // Random connections
                neurons.forEach((n, i) => {
                    for(let j=0; j<2; j++) {
                        let target = neurons[Math.floor(Math.random()*neurons.length)];
                        if(n !== target) connections.push({from: n, to: target});
                    }
                });
            },
            update() {
                neurons.forEach(n => {
                    let spiked = n.update(1, Math.random()*5); // Base noise
                    if (spiked) {
                        connections.filter(c => c.from === n).forEach(c => pulses.push(new Pulse(c.from, c.to)));
                    }
                });
                for(let i=pulses.length-1; i>=0; i--) {
                    if(pulses[i].update()) {
                        pulses[i].to.v += 15; // Synaptic input
                        pulses.splice(i, 1);
                    }
                }
            },
            draw() {
                ctx.fillStyle = '#000814'; ctx.fillRect(0,0,width,height);
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)'; ctx.lineWidth = 1;
                connections.forEach(c => {
                    ctx.beginPath(); ctx.moveTo(c.from.x, c.from.y); ctx.lineTo(c.to.x, c.to.y); ctx.stroke();
                });
                neurons.forEach(n => n.draw());
                pulses.forEach(p => p.draw());
            }
        };

        function animate() { Simulation.update(); Simulation.draw(); requestAnimationFrame(animate); }
        Simulation.init(); animate();
        window.onclick = (e) => {
            neurons.forEach(n => {
                if(Math.hypot(n.x - e.clientX, n.y - e.clientY) < 30) n.v += 30;
            });
        }
    </script>
</body>
</html>
